//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//     ANTLR Version: 4.8
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------

// Generated from PulsarAsmGrammar.g4 by ANTLR 4.8

// Unreachable code detected
#pragma warning disable 0162
// The variable '...' is assigned but its value is never used
#pragma warning disable 0219
// Missing XML comment for publicly visible type or member '...'
#pragma warning disable 1591
// Ambiguous reference in cref attribute
#pragma warning disable 419

using System;
using System.IO;
using System.Text;
using System.Diagnostics;
using System.Collections.Generic;
using Antlr4.Runtime;
using Antlr4.Runtime.Atn;
using Antlr4.Runtime.Misc;
using Antlr4.Runtime.Tree;
using DFA = Antlr4.Runtime.Dfa.DFA;

[System.CodeDom.Compiler.GeneratedCode("ANTLR", "4.8")]
[System.CLSCompliant(false)]
public partial class PulsarAsmGrammarParser : Parser {
	protected static DFA[] decisionToDFA;
	protected static PredictionContextCache sharedContextCache = new PredictionContextCache();
	public const int
		WHITESPACE=1, NEWLINE=2, COMMENTARY=3, MNEMONIC=4, PLUS=5, SIGN=6, COMMA=7, 
		DECIMAL_INTEGER=8, SIGNED_DECIMAL_INTEGER=9, BIN_INTEGER=10, HEX_INTEGER=11, 
		BITNESS=12, ADDRESSES=13, ENDIANNESS_LITTLE=14, ENDIANNESS_BIG=15, DATA_TYPE_SPECIFIER=16, 
		ADDRESS_TYPE_SPECIFIER=17, UNALIGNED=18, GP_REGISTER=19, SYSTEM_REGISTER=20, 
		INFO_REGISTER=21, CONDITION=22, PROC=23, PROC_START=24, PROC_END=25, SQ_L=26, 
		SQ_R=27, TILD=28, COLON=29, OFFSET=30, LOCAL=31, SETBOOL=32, TEXT_STRING=33, 
		IDENTIFIER=34;
	public const int
		RULE_bitness_directive = 0, RULE_address_directive = 1, RULE_directive = 2, 
		RULE_proc_header = 3, RULE_instruction_specifier = 4, RULE_unsigned_integer = 5, 
		RULE_integer = 6, RULE_data_definition = 7, RULE_data_definition_sequence_inner = 8, 
		RULE_data_definition_sequence = 9, RULE_data_identifier = 10, RULE_data_definition_statement = 11, 
		RULE_op_immediate = 12, RULE_op_register = 13, RULE_op_imm_memory = 14, 
		RULE_op_indirect = 15, RULE_op_local = 16, RULE_op_base_w_offset = 17, 
		RULE_op_base_w_register = 18, RULE_op_relative = 19, RULE_op_data = 20, 
		RULE_jmp_operand = 21, RULE_st_operand = 22, RULE_operands = 23, RULE_label = 24, 
		RULE_instr_specifier_sequence = 25, RULE_instr_body = 26, RULE_jump_sequence = 27, 
		RULE_conditional_body_shared = 28, RULE_conditional_instruction = 29, 
		RULE_conditional_cp_instruction = 30, RULE_instruction = 31, RULE_proc_element = 32, 
		RULE_proc_element_sequence = 33, RULE_procedure = 34, RULE_asm_file_element = 35, 
		RULE_asm_file_element_sequence = 36, RULE_asm_file = 37;
	public static readonly string[] ruleNames = {
		"bitness_directive", "address_directive", "directive", "proc_header", 
		"instruction_specifier", "unsigned_integer", "integer", "data_definition", 
		"data_definition_sequence_inner", "data_definition_sequence", "data_identifier", 
		"data_definition_statement", "op_immediate", "op_register", "op_imm_memory", 
		"op_indirect", "op_local", "op_base_w_offset", "op_base_w_register", "op_relative", 
		"op_data", "jmp_operand", "st_operand", "operands", "label", "instr_specifier_sequence", 
		"instr_body", "jump_sequence", "conditional_body_shared", "conditional_instruction", 
		"conditional_cp_instruction", "instruction", "proc_element", "proc_element_sequence", 
		"procedure", "asm_file_element", "asm_file_element_sequence", "asm_file"
	};

	private static readonly string[] _LiteralNames = {
		null, null, null, null, null, "'+'", null, "','", null, null, null, null, 
		"'.BITNESS'", "'.ADDRESSES'", "'.LITTLEENDIAN'", "'.BIGENDIAN'", null, 
		null, "'.UNALIGNED'", null, null, null, null, "'.PROC'", "'{'", "'}'", 
		"'['", "']'", "'~'", "':'", "'OFFSET'", "'LOCAL'", "'SETBOOL'"
	};
	private static readonly string[] _SymbolicNames = {
		null, "WHITESPACE", "NEWLINE", "COMMENTARY", "MNEMONIC", "PLUS", "SIGN", 
		"COMMA", "DECIMAL_INTEGER", "SIGNED_DECIMAL_INTEGER", "BIN_INTEGER", "HEX_INTEGER", 
		"BITNESS", "ADDRESSES", "ENDIANNESS_LITTLE", "ENDIANNESS_BIG", "DATA_TYPE_SPECIFIER", 
		"ADDRESS_TYPE_SPECIFIER", "UNALIGNED", "GP_REGISTER", "SYSTEM_REGISTER", 
		"INFO_REGISTER", "CONDITION", "PROC", "PROC_START", "PROC_END", "SQ_L", 
		"SQ_R", "TILD", "COLON", "OFFSET", "LOCAL", "SETBOOL", "TEXT_STRING", 
		"IDENTIFIER"
	};
	public static readonly IVocabulary DefaultVocabulary = new Vocabulary(_LiteralNames, _SymbolicNames);

	[NotNull]
	public override IVocabulary Vocabulary
	{
		get
		{
			return DefaultVocabulary;
		}
	}

	public override string GrammarFileName { get { return "PulsarAsmGrammar.g4"; } }

	public override string[] RuleNames { get { return ruleNames; } }

	public override string SerializedAtn { get { return new string(_serializedATN); } }

	static PulsarAsmGrammarParser() {
		decisionToDFA = new DFA[_ATN.NumberOfDecisions];
		for (int i = 0; i < _ATN.NumberOfDecisions; i++) {
			decisionToDFA[i] = new DFA(_ATN.GetDecisionState(i), i);
		}
	}

		public PulsarAsmGrammarParser(ITokenStream input) : this(input, Console.Out, Console.Error) { }

		public PulsarAsmGrammarParser(ITokenStream input, TextWriter output, TextWriter errorOutput)
		: base(input, output, errorOutput)
	{
		Interpreter = new ParserATNSimulator(this, _ATN, decisionToDFA, sharedContextCache);
	}

	public partial class Bitness_directiveContext : ParserRuleContext {
		public ITerminalNode BITNESS() { return GetToken(PulsarAsmGrammarParser.BITNESS, 0); }
		public ITerminalNode DECIMAL_INTEGER() { return GetToken(PulsarAsmGrammarParser.DECIMAL_INTEGER, 0); }
		public Bitness_directiveContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_bitness_directive; } }
		public override void EnterRule(IParseTreeListener listener) {
			IPulsarAsmGrammarListener typedListener = listener as IPulsarAsmGrammarListener;
			if (typedListener != null) typedListener.EnterBitness_directive(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IPulsarAsmGrammarListener typedListener = listener as IPulsarAsmGrammarListener;
			if (typedListener != null) typedListener.ExitBitness_directive(this);
		}
	}

	[RuleVersion(0)]
	public Bitness_directiveContext bitness_directive() {
		Bitness_directiveContext _localctx = new Bitness_directiveContext(Context, State);
		EnterRule(_localctx, 0, RULE_bitness_directive);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 76; Match(BITNESS);
			State = 77; Match(DECIMAL_INTEGER);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class Address_directiveContext : ParserRuleContext {
		public ITerminalNode ADDRESSES() { return GetToken(PulsarAsmGrammarParser.ADDRESSES, 0); }
		public ITerminalNode DECIMAL_INTEGER() { return GetToken(PulsarAsmGrammarParser.DECIMAL_INTEGER, 0); }
		public Address_directiveContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_address_directive; } }
		public override void EnterRule(IParseTreeListener listener) {
			IPulsarAsmGrammarListener typedListener = listener as IPulsarAsmGrammarListener;
			if (typedListener != null) typedListener.EnterAddress_directive(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IPulsarAsmGrammarListener typedListener = listener as IPulsarAsmGrammarListener;
			if (typedListener != null) typedListener.ExitAddress_directive(this);
		}
	}

	[RuleVersion(0)]
	public Address_directiveContext address_directive() {
		Address_directiveContext _localctx = new Address_directiveContext(Context, State);
		EnterRule(_localctx, 2, RULE_address_directive);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 79; Match(ADDRESSES);
			State = 80; Match(DECIMAL_INTEGER);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class DirectiveContext : ParserRuleContext {
		public Bitness_directiveContext bitness_directive() {
			return GetRuleContext<Bitness_directiveContext>(0);
		}
		public Address_directiveContext address_directive() {
			return GetRuleContext<Address_directiveContext>(0);
		}
		public ITerminalNode ENDIANNESS_LITTLE() { return GetToken(PulsarAsmGrammarParser.ENDIANNESS_LITTLE, 0); }
		public ITerminalNode ENDIANNESS_BIG() { return GetToken(PulsarAsmGrammarParser.ENDIANNESS_BIG, 0); }
		public DirectiveContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_directive; } }
		public override void EnterRule(IParseTreeListener listener) {
			IPulsarAsmGrammarListener typedListener = listener as IPulsarAsmGrammarListener;
			if (typedListener != null) typedListener.EnterDirective(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IPulsarAsmGrammarListener typedListener = listener as IPulsarAsmGrammarListener;
			if (typedListener != null) typedListener.ExitDirective(this);
		}
	}

	[RuleVersion(0)]
	public DirectiveContext directive() {
		DirectiveContext _localctx = new DirectiveContext(Context, State);
		EnterRule(_localctx, 4, RULE_directive);
		try {
			State = 86;
			ErrorHandler.Sync(this);
			switch (TokenStream.LA(1)) {
			case BITNESS:
				EnterOuterAlt(_localctx, 1);
				{
				State = 82; bitness_directive();
				}
				break;
			case ADDRESSES:
				EnterOuterAlt(_localctx, 2);
				{
				State = 83; address_directive();
				}
				break;
			case ENDIANNESS_LITTLE:
				EnterOuterAlt(_localctx, 3);
				{
				State = 84; Match(ENDIANNESS_LITTLE);
				}
				break;
			case ENDIANNESS_BIG:
				EnterOuterAlt(_localctx, 4);
				{
				State = 85; Match(ENDIANNESS_BIG);
				}
				break;
			default:
				throw new NoViableAltException(this);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class Proc_headerContext : ParserRuleContext {
		public ITerminalNode PROC() { return GetToken(PulsarAsmGrammarParser.PROC, 0); }
		public ITerminalNode IDENTIFIER() { return GetToken(PulsarAsmGrammarParser.IDENTIFIER, 0); }
		public Proc_headerContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_proc_header; } }
		public override void EnterRule(IParseTreeListener listener) {
			IPulsarAsmGrammarListener typedListener = listener as IPulsarAsmGrammarListener;
			if (typedListener != null) typedListener.EnterProc_header(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IPulsarAsmGrammarListener typedListener = listener as IPulsarAsmGrammarListener;
			if (typedListener != null) typedListener.ExitProc_header(this);
		}
	}

	[RuleVersion(0)]
	public Proc_headerContext proc_header() {
		Proc_headerContext _localctx = new Proc_headerContext(Context, State);
		EnterRule(_localctx, 6, RULE_proc_header);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 88; Match(PROC);
			State = 89; Match(IDENTIFIER);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class Instruction_specifierContext : ParserRuleContext {
		public ITerminalNode DATA_TYPE_SPECIFIER() { return GetToken(PulsarAsmGrammarParser.DATA_TYPE_SPECIFIER, 0); }
		public ITerminalNode ADDRESS_TYPE_SPECIFIER() { return GetToken(PulsarAsmGrammarParser.ADDRESS_TYPE_SPECIFIER, 0); }
		public ITerminalNode UNALIGNED() { return GetToken(PulsarAsmGrammarParser.UNALIGNED, 0); }
		public Instruction_specifierContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_instruction_specifier; } }
		public override void EnterRule(IParseTreeListener listener) {
			IPulsarAsmGrammarListener typedListener = listener as IPulsarAsmGrammarListener;
			if (typedListener != null) typedListener.EnterInstruction_specifier(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IPulsarAsmGrammarListener typedListener = listener as IPulsarAsmGrammarListener;
			if (typedListener != null) typedListener.ExitInstruction_specifier(this);
		}
	}

	[RuleVersion(0)]
	public Instruction_specifierContext instruction_specifier() {
		Instruction_specifierContext _localctx = new Instruction_specifierContext(Context, State);
		EnterRule(_localctx, 8, RULE_instruction_specifier);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 91;
			_la = TokenStream.LA(1);
			if ( !((((_la) & ~0x3f) == 0 && ((1L << _la) & ((1L << DATA_TYPE_SPECIFIER) | (1L << ADDRESS_TYPE_SPECIFIER) | (1L << UNALIGNED))) != 0)) ) {
			ErrorHandler.RecoverInline(this);
			}
			else {
				ErrorHandler.ReportMatch(this);
			    Consume();
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class Unsigned_integerContext : ParserRuleContext {
		public ITerminalNode BIN_INTEGER() { return GetToken(PulsarAsmGrammarParser.BIN_INTEGER, 0); }
		public ITerminalNode DECIMAL_INTEGER() { return GetToken(PulsarAsmGrammarParser.DECIMAL_INTEGER, 0); }
		public ITerminalNode HEX_INTEGER() { return GetToken(PulsarAsmGrammarParser.HEX_INTEGER, 0); }
		public Unsigned_integerContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_unsigned_integer; } }
		public override void EnterRule(IParseTreeListener listener) {
			IPulsarAsmGrammarListener typedListener = listener as IPulsarAsmGrammarListener;
			if (typedListener != null) typedListener.EnterUnsigned_integer(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IPulsarAsmGrammarListener typedListener = listener as IPulsarAsmGrammarListener;
			if (typedListener != null) typedListener.ExitUnsigned_integer(this);
		}
	}

	[RuleVersion(0)]
	public Unsigned_integerContext unsigned_integer() {
		Unsigned_integerContext _localctx = new Unsigned_integerContext(Context, State);
		EnterRule(_localctx, 10, RULE_unsigned_integer);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 93;
			_la = TokenStream.LA(1);
			if ( !((((_la) & ~0x3f) == 0 && ((1L << _la) & ((1L << DECIMAL_INTEGER) | (1L << BIN_INTEGER) | (1L << HEX_INTEGER))) != 0)) ) {
			ErrorHandler.RecoverInline(this);
			}
			else {
				ErrorHandler.ReportMatch(this);
			    Consume();
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class IntegerContext : ParserRuleContext {
		public Unsigned_integerContext unsigned_integer() {
			return GetRuleContext<Unsigned_integerContext>(0);
		}
		public ITerminalNode SIGNED_DECIMAL_INTEGER() { return GetToken(PulsarAsmGrammarParser.SIGNED_DECIMAL_INTEGER, 0); }
		public IntegerContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_integer; } }
		public override void EnterRule(IParseTreeListener listener) {
			IPulsarAsmGrammarListener typedListener = listener as IPulsarAsmGrammarListener;
			if (typedListener != null) typedListener.EnterInteger(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IPulsarAsmGrammarListener typedListener = listener as IPulsarAsmGrammarListener;
			if (typedListener != null) typedListener.ExitInteger(this);
		}
	}

	[RuleVersion(0)]
	public IntegerContext integer() {
		IntegerContext _localctx = new IntegerContext(Context, State);
		EnterRule(_localctx, 12, RULE_integer);
		try {
			State = 97;
			ErrorHandler.Sync(this);
			switch (TokenStream.LA(1)) {
			case DECIMAL_INTEGER:
			case BIN_INTEGER:
			case HEX_INTEGER:
				EnterOuterAlt(_localctx, 1);
				{
				State = 95; unsigned_integer();
				}
				break;
			case SIGNED_DECIMAL_INTEGER:
				EnterOuterAlt(_localctx, 2);
				{
				State = 96; Match(SIGNED_DECIMAL_INTEGER);
				}
				break;
			default:
				throw new NoViableAltException(this);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class Data_definitionContext : ParserRuleContext {
		public IntegerContext integer() {
			return GetRuleContext<IntegerContext>(0);
		}
		public ITerminalNode TEXT_STRING() { return GetToken(PulsarAsmGrammarParser.TEXT_STRING, 0); }
		public Data_definitionContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_data_definition; } }
		public override void EnterRule(IParseTreeListener listener) {
			IPulsarAsmGrammarListener typedListener = listener as IPulsarAsmGrammarListener;
			if (typedListener != null) typedListener.EnterData_definition(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IPulsarAsmGrammarListener typedListener = listener as IPulsarAsmGrammarListener;
			if (typedListener != null) typedListener.ExitData_definition(this);
		}
	}

	[RuleVersion(0)]
	public Data_definitionContext data_definition() {
		Data_definitionContext _localctx = new Data_definitionContext(Context, State);
		EnterRule(_localctx, 14, RULE_data_definition);
		try {
			State = 101;
			ErrorHandler.Sync(this);
			switch (TokenStream.LA(1)) {
			case DECIMAL_INTEGER:
			case SIGNED_DECIMAL_INTEGER:
			case BIN_INTEGER:
			case HEX_INTEGER:
				EnterOuterAlt(_localctx, 1);
				{
				State = 99; integer();
				}
				break;
			case TEXT_STRING:
				EnterOuterAlt(_localctx, 2);
				{
				State = 100; Match(TEXT_STRING);
				}
				break;
			default:
				throw new NoViableAltException(this);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class Data_definition_sequence_innerContext : ParserRuleContext {
		public Data_definitionContext data_definition() {
			return GetRuleContext<Data_definitionContext>(0);
		}
		public ITerminalNode COMMA() { return GetToken(PulsarAsmGrammarParser.COMMA, 0); }
		public Data_definition_sequence_innerContext data_definition_sequence_inner() {
			return GetRuleContext<Data_definition_sequence_innerContext>(0);
		}
		public Data_definition_sequence_innerContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_data_definition_sequence_inner; } }
		public override void EnterRule(IParseTreeListener listener) {
			IPulsarAsmGrammarListener typedListener = listener as IPulsarAsmGrammarListener;
			if (typedListener != null) typedListener.EnterData_definition_sequence_inner(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IPulsarAsmGrammarListener typedListener = listener as IPulsarAsmGrammarListener;
			if (typedListener != null) typedListener.ExitData_definition_sequence_inner(this);
		}
	}

	[RuleVersion(0)]
	public Data_definition_sequence_innerContext data_definition_sequence_inner() {
		Data_definition_sequence_innerContext _localctx = new Data_definition_sequence_innerContext(Context, State);
		EnterRule(_localctx, 16, RULE_data_definition_sequence_inner);
		try {
			State = 110;
			ErrorHandler.Sync(this);
			switch ( Interpreter.AdaptivePredict(TokenStream,3,Context) ) {
			case 1:
				EnterOuterAlt(_localctx, 1);
				{
				State = 103; data_definition();
				State = 104; Match(COMMA);
				State = 105; data_definition_sequence_inner();
				}
				break;
			case 2:
				EnterOuterAlt(_localctx, 2);
				{
				State = 107; data_definition();
				State = 108; Match(COMMA);
				}
				break;
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class Data_definition_sequenceContext : ParserRuleContext {
		public Data_definition_sequence_innerContext data_definition_sequence_inner() {
			return GetRuleContext<Data_definition_sequence_innerContext>(0);
		}
		public Data_definitionContext data_definition() {
			return GetRuleContext<Data_definitionContext>(0);
		}
		public Data_definition_sequenceContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_data_definition_sequence; } }
		public override void EnterRule(IParseTreeListener listener) {
			IPulsarAsmGrammarListener typedListener = listener as IPulsarAsmGrammarListener;
			if (typedListener != null) typedListener.EnterData_definition_sequence(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IPulsarAsmGrammarListener typedListener = listener as IPulsarAsmGrammarListener;
			if (typedListener != null) typedListener.ExitData_definition_sequence(this);
		}
	}

	[RuleVersion(0)]
	public Data_definition_sequenceContext data_definition_sequence() {
		Data_definition_sequenceContext _localctx = new Data_definition_sequenceContext(Context, State);
		EnterRule(_localctx, 18, RULE_data_definition_sequence);
		try {
			State = 116;
			ErrorHandler.Sync(this);
			switch ( Interpreter.AdaptivePredict(TokenStream,4,Context) ) {
			case 1:
				EnterOuterAlt(_localctx, 1);
				{
				State = 112; data_definition_sequence_inner();
				State = 113; data_definition();
				}
				break;
			case 2:
				EnterOuterAlt(_localctx, 2);
				{
				State = 115; data_definition();
				}
				break;
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class Data_identifierContext : ParserRuleContext {
		public ITerminalNode IDENTIFIER() { return GetToken(PulsarAsmGrammarParser.IDENTIFIER, 0); }
		public Data_identifierContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_data_identifier; } }
		public override void EnterRule(IParseTreeListener listener) {
			IPulsarAsmGrammarListener typedListener = listener as IPulsarAsmGrammarListener;
			if (typedListener != null) typedListener.EnterData_identifier(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IPulsarAsmGrammarListener typedListener = listener as IPulsarAsmGrammarListener;
			if (typedListener != null) typedListener.ExitData_identifier(this);
		}
	}

	[RuleVersion(0)]
	public Data_identifierContext data_identifier() {
		Data_identifierContext _localctx = new Data_identifierContext(Context, State);
		EnterRule(_localctx, 20, RULE_data_identifier);
		try {
			State = 120;
			ErrorHandler.Sync(this);
			switch (TokenStream.LA(1)) {
			case IDENTIFIER:
				EnterOuterAlt(_localctx, 1);
				{
				State = 118; Match(IDENTIFIER);
				}
				break;
			case DECIMAL_INTEGER:
			case SIGNED_DECIMAL_INTEGER:
			case BIN_INTEGER:
			case HEX_INTEGER:
			case TEXT_STRING:
				EnterOuterAlt(_localctx, 2);
				{
				}
				break;
			default:
				throw new NoViableAltException(this);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class Data_definition_statementContext : ParserRuleContext {
		public ITerminalNode DATA_TYPE_SPECIFIER() { return GetToken(PulsarAsmGrammarParser.DATA_TYPE_SPECIFIER, 0); }
		public Data_identifierContext data_identifier() {
			return GetRuleContext<Data_identifierContext>(0);
		}
		public Data_definition_sequenceContext data_definition_sequence() {
			return GetRuleContext<Data_definition_sequenceContext>(0);
		}
		public Data_definition_statementContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_data_definition_statement; } }
		public override void EnterRule(IParseTreeListener listener) {
			IPulsarAsmGrammarListener typedListener = listener as IPulsarAsmGrammarListener;
			if (typedListener != null) typedListener.EnterData_definition_statement(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IPulsarAsmGrammarListener typedListener = listener as IPulsarAsmGrammarListener;
			if (typedListener != null) typedListener.ExitData_definition_statement(this);
		}
	}

	[RuleVersion(0)]
	public Data_definition_statementContext data_definition_statement() {
		Data_definition_statementContext _localctx = new Data_definition_statementContext(Context, State);
		EnterRule(_localctx, 22, RULE_data_definition_statement);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 122; Match(DATA_TYPE_SPECIFIER);
			State = 123; data_identifier();
			State = 124; data_definition_sequence();
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class Op_immediateContext : ParserRuleContext {
		public ITerminalNode OFFSET() { return GetToken(PulsarAsmGrammarParser.OFFSET, 0); }
		public ITerminalNode IDENTIFIER() { return GetToken(PulsarAsmGrammarParser.IDENTIFIER, 0); }
		public IntegerContext integer() {
			return GetRuleContext<IntegerContext>(0);
		}
		public Op_immediateContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_op_immediate; } }
		public override void EnterRule(IParseTreeListener listener) {
			IPulsarAsmGrammarListener typedListener = listener as IPulsarAsmGrammarListener;
			if (typedListener != null) typedListener.EnterOp_immediate(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IPulsarAsmGrammarListener typedListener = listener as IPulsarAsmGrammarListener;
			if (typedListener != null) typedListener.ExitOp_immediate(this);
		}
	}

	[RuleVersion(0)]
	public Op_immediateContext op_immediate() {
		Op_immediateContext _localctx = new Op_immediateContext(Context, State);
		EnterRule(_localctx, 24, RULE_op_immediate);
		try {
			State = 129;
			ErrorHandler.Sync(this);
			switch (TokenStream.LA(1)) {
			case OFFSET:
				EnterOuterAlt(_localctx, 1);
				{
				State = 126; Match(OFFSET);
				State = 127; Match(IDENTIFIER);
				}
				break;
			case DECIMAL_INTEGER:
			case SIGNED_DECIMAL_INTEGER:
			case BIN_INTEGER:
			case HEX_INTEGER:
				EnterOuterAlt(_localctx, 2);
				{
				State = 128; integer();
				}
				break;
			default:
				throw new NoViableAltException(this);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class Op_registerContext : ParserRuleContext {
		public ITerminalNode GP_REGISTER() { return GetToken(PulsarAsmGrammarParser.GP_REGISTER, 0); }
		public ITerminalNode INFO_REGISTER() { return GetToken(PulsarAsmGrammarParser.INFO_REGISTER, 0); }
		public ITerminalNode SYSTEM_REGISTER() { return GetToken(PulsarAsmGrammarParser.SYSTEM_REGISTER, 0); }
		public Op_registerContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_op_register; } }
		public override void EnterRule(IParseTreeListener listener) {
			IPulsarAsmGrammarListener typedListener = listener as IPulsarAsmGrammarListener;
			if (typedListener != null) typedListener.EnterOp_register(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IPulsarAsmGrammarListener typedListener = listener as IPulsarAsmGrammarListener;
			if (typedListener != null) typedListener.ExitOp_register(this);
		}
	}

	[RuleVersion(0)]
	public Op_registerContext op_register() {
		Op_registerContext _localctx = new Op_registerContext(Context, State);
		EnterRule(_localctx, 26, RULE_op_register);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 131;
			_la = TokenStream.LA(1);
			if ( !((((_la) & ~0x3f) == 0 && ((1L << _la) & ((1L << GP_REGISTER) | (1L << SYSTEM_REGISTER) | (1L << INFO_REGISTER))) != 0)) ) {
			ErrorHandler.RecoverInline(this);
			}
			else {
				ErrorHandler.ReportMatch(this);
			    Consume();
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class Op_imm_memoryContext : ParserRuleContext {
		public ITerminalNode SQ_L() { return GetToken(PulsarAsmGrammarParser.SQ_L, 0); }
		public IntegerContext integer() {
			return GetRuleContext<IntegerContext>(0);
		}
		public ITerminalNode SQ_R() { return GetToken(PulsarAsmGrammarParser.SQ_R, 0); }
		public Op_imm_memoryContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_op_imm_memory; } }
		public override void EnterRule(IParseTreeListener listener) {
			IPulsarAsmGrammarListener typedListener = listener as IPulsarAsmGrammarListener;
			if (typedListener != null) typedListener.EnterOp_imm_memory(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IPulsarAsmGrammarListener typedListener = listener as IPulsarAsmGrammarListener;
			if (typedListener != null) typedListener.ExitOp_imm_memory(this);
		}
	}

	[RuleVersion(0)]
	public Op_imm_memoryContext op_imm_memory() {
		Op_imm_memoryContext _localctx = new Op_imm_memoryContext(Context, State);
		EnterRule(_localctx, 28, RULE_op_imm_memory);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 133; Match(SQ_L);
			State = 134; integer();
			State = 135; Match(SQ_R);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class Op_indirectContext : ParserRuleContext {
		public ITerminalNode SQ_L() { return GetToken(PulsarAsmGrammarParser.SQ_L, 0); }
		public ITerminalNode GP_REGISTER() { return GetToken(PulsarAsmGrammarParser.GP_REGISTER, 0); }
		public ITerminalNode SQ_R() { return GetToken(PulsarAsmGrammarParser.SQ_R, 0); }
		public Op_indirectContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_op_indirect; } }
		public override void EnterRule(IParseTreeListener listener) {
			IPulsarAsmGrammarListener typedListener = listener as IPulsarAsmGrammarListener;
			if (typedListener != null) typedListener.EnterOp_indirect(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IPulsarAsmGrammarListener typedListener = listener as IPulsarAsmGrammarListener;
			if (typedListener != null) typedListener.ExitOp_indirect(this);
		}
	}

	[RuleVersion(0)]
	public Op_indirectContext op_indirect() {
		Op_indirectContext _localctx = new Op_indirectContext(Context, State);
		EnterRule(_localctx, 30, RULE_op_indirect);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 137; Match(SQ_L);
			State = 138; Match(GP_REGISTER);
			State = 139; Match(SQ_R);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class Op_localContext : ParserRuleContext {
		public ITerminalNode LOCAL() { return GetToken(PulsarAsmGrammarParser.LOCAL, 0); }
		public ITerminalNode SQ_L() { return GetToken(PulsarAsmGrammarParser.SQ_L, 0); }
		public IntegerContext integer() {
			return GetRuleContext<IntegerContext>(0);
		}
		public ITerminalNode SQ_R() { return GetToken(PulsarAsmGrammarParser.SQ_R, 0); }
		public Op_localContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_op_local; } }
		public override void EnterRule(IParseTreeListener listener) {
			IPulsarAsmGrammarListener typedListener = listener as IPulsarAsmGrammarListener;
			if (typedListener != null) typedListener.EnterOp_local(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IPulsarAsmGrammarListener typedListener = listener as IPulsarAsmGrammarListener;
			if (typedListener != null) typedListener.ExitOp_local(this);
		}
	}

	[RuleVersion(0)]
	public Op_localContext op_local() {
		Op_localContext _localctx = new Op_localContext(Context, State);
		EnterRule(_localctx, 32, RULE_op_local);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 141; Match(LOCAL);
			State = 142; Match(SQ_L);
			State = 143; integer();
			State = 144; Match(SQ_R);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class Op_base_w_offsetContext : ParserRuleContext {
		public ITerminalNode SQ_L() { return GetToken(PulsarAsmGrammarParser.SQ_L, 0); }
		public ITerminalNode GP_REGISTER() { return GetToken(PulsarAsmGrammarParser.GP_REGISTER, 0); }
		public ITerminalNode SIGN() { return GetToken(PulsarAsmGrammarParser.SIGN, 0); }
		public Unsigned_integerContext unsigned_integer() {
			return GetRuleContext<Unsigned_integerContext>(0);
		}
		public ITerminalNode SQ_R() { return GetToken(PulsarAsmGrammarParser.SQ_R, 0); }
		public Op_base_w_offsetContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_op_base_w_offset; } }
		public override void EnterRule(IParseTreeListener listener) {
			IPulsarAsmGrammarListener typedListener = listener as IPulsarAsmGrammarListener;
			if (typedListener != null) typedListener.EnterOp_base_w_offset(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IPulsarAsmGrammarListener typedListener = listener as IPulsarAsmGrammarListener;
			if (typedListener != null) typedListener.ExitOp_base_w_offset(this);
		}
	}

	[RuleVersion(0)]
	public Op_base_w_offsetContext op_base_w_offset() {
		Op_base_w_offsetContext _localctx = new Op_base_w_offsetContext(Context, State);
		EnterRule(_localctx, 34, RULE_op_base_w_offset);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 146; Match(SQ_L);
			State = 147; Match(GP_REGISTER);
			State = 148; Match(SIGN);
			State = 149; unsigned_integer();
			State = 150; Match(SQ_R);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class Op_base_w_registerContext : ParserRuleContext {
		public ITerminalNode SQ_L() { return GetToken(PulsarAsmGrammarParser.SQ_L, 0); }
		public ITerminalNode[] GP_REGISTER() { return GetTokens(PulsarAsmGrammarParser.GP_REGISTER); }
		public ITerminalNode GP_REGISTER(int i) {
			return GetToken(PulsarAsmGrammarParser.GP_REGISTER, i);
		}
		public ITerminalNode PLUS() { return GetToken(PulsarAsmGrammarParser.PLUS, 0); }
		public ITerminalNode SQ_R() { return GetToken(PulsarAsmGrammarParser.SQ_R, 0); }
		public Op_base_w_registerContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_op_base_w_register; } }
		public override void EnterRule(IParseTreeListener listener) {
			IPulsarAsmGrammarListener typedListener = listener as IPulsarAsmGrammarListener;
			if (typedListener != null) typedListener.EnterOp_base_w_register(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IPulsarAsmGrammarListener typedListener = listener as IPulsarAsmGrammarListener;
			if (typedListener != null) typedListener.ExitOp_base_w_register(this);
		}
	}

	[RuleVersion(0)]
	public Op_base_w_registerContext op_base_w_register() {
		Op_base_w_registerContext _localctx = new Op_base_w_registerContext(Context, State);
		EnterRule(_localctx, 36, RULE_op_base_w_register);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 152; Match(SQ_L);
			State = 153; Match(GP_REGISTER);
			State = 154; Match(PLUS);
			State = 155; Match(GP_REGISTER);
			State = 156; Match(SQ_R);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class Op_relativeContext : ParserRuleContext {
		public ITerminalNode TILD() { return GetToken(PulsarAsmGrammarParser.TILD, 0); }
		public IntegerContext integer() {
			return GetRuleContext<IntegerContext>(0);
		}
		public Op_relativeContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_op_relative; } }
		public override void EnterRule(IParseTreeListener listener) {
			IPulsarAsmGrammarListener typedListener = listener as IPulsarAsmGrammarListener;
			if (typedListener != null) typedListener.EnterOp_relative(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IPulsarAsmGrammarListener typedListener = listener as IPulsarAsmGrammarListener;
			if (typedListener != null) typedListener.ExitOp_relative(this);
		}
	}

	[RuleVersion(0)]
	public Op_relativeContext op_relative() {
		Op_relativeContext _localctx = new Op_relativeContext(Context, State);
		EnterRule(_localctx, 38, RULE_op_relative);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 158; Match(TILD);
			State = 159; integer();
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class Op_dataContext : ParserRuleContext {
		public ITerminalNode IDENTIFIER() { return GetToken(PulsarAsmGrammarParser.IDENTIFIER, 0); }
		public Op_dataContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_op_data; } }
		public override void EnterRule(IParseTreeListener listener) {
			IPulsarAsmGrammarListener typedListener = listener as IPulsarAsmGrammarListener;
			if (typedListener != null) typedListener.EnterOp_data(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IPulsarAsmGrammarListener typedListener = listener as IPulsarAsmGrammarListener;
			if (typedListener != null) typedListener.ExitOp_data(this);
		}
	}

	[RuleVersion(0)]
	public Op_dataContext op_data() {
		Op_dataContext _localctx = new Op_dataContext(Context, State);
		EnterRule(_localctx, 40, RULE_op_data);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 161; Match(IDENTIFIER);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class Jmp_operandContext : ParserRuleContext {
		public Op_imm_memoryContext op_imm_memory() {
			return GetRuleContext<Op_imm_memoryContext>(0);
		}
		public Op_indirectContext op_indirect() {
			return GetRuleContext<Op_indirectContext>(0);
		}
		public Op_localContext op_local() {
			return GetRuleContext<Op_localContext>(0);
		}
		public Op_base_w_offsetContext op_base_w_offset() {
			return GetRuleContext<Op_base_w_offsetContext>(0);
		}
		public Op_base_w_registerContext op_base_w_register() {
			return GetRuleContext<Op_base_w_registerContext>(0);
		}
		public Op_relativeContext op_relative() {
			return GetRuleContext<Op_relativeContext>(0);
		}
		public Op_dataContext op_data() {
			return GetRuleContext<Op_dataContext>(0);
		}
		public Jmp_operandContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_jmp_operand; } }
		public override void EnterRule(IParseTreeListener listener) {
			IPulsarAsmGrammarListener typedListener = listener as IPulsarAsmGrammarListener;
			if (typedListener != null) typedListener.EnterJmp_operand(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IPulsarAsmGrammarListener typedListener = listener as IPulsarAsmGrammarListener;
			if (typedListener != null) typedListener.ExitJmp_operand(this);
		}
	}

	[RuleVersion(0)]
	public Jmp_operandContext jmp_operand() {
		Jmp_operandContext _localctx = new Jmp_operandContext(Context, State);
		EnterRule(_localctx, 42, RULE_jmp_operand);
		try {
			State = 170;
			ErrorHandler.Sync(this);
			switch ( Interpreter.AdaptivePredict(TokenStream,7,Context) ) {
			case 1:
				EnterOuterAlt(_localctx, 1);
				{
				State = 163; op_imm_memory();
				}
				break;
			case 2:
				EnterOuterAlt(_localctx, 2);
				{
				State = 164; op_indirect();
				}
				break;
			case 3:
				EnterOuterAlt(_localctx, 3);
				{
				State = 165; op_local();
				}
				break;
			case 4:
				EnterOuterAlt(_localctx, 4);
				{
				State = 166; op_base_w_offset();
				}
				break;
			case 5:
				EnterOuterAlt(_localctx, 5);
				{
				State = 167; op_base_w_register();
				}
				break;
			case 6:
				EnterOuterAlt(_localctx, 6);
				{
				State = 168; op_relative();
				}
				break;
			case 7:
				EnterOuterAlt(_localctx, 7);
				{
				State = 169; op_data();
				}
				break;
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class St_operandContext : ParserRuleContext {
		public Op_registerContext op_register() {
			return GetRuleContext<Op_registerContext>(0);
		}
		public Jmp_operandContext jmp_operand() {
			return GetRuleContext<Jmp_operandContext>(0);
		}
		public St_operandContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_st_operand; } }
		public override void EnterRule(IParseTreeListener listener) {
			IPulsarAsmGrammarListener typedListener = listener as IPulsarAsmGrammarListener;
			if (typedListener != null) typedListener.EnterSt_operand(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IPulsarAsmGrammarListener typedListener = listener as IPulsarAsmGrammarListener;
			if (typedListener != null) typedListener.ExitSt_operand(this);
		}
	}

	[RuleVersion(0)]
	public St_operandContext st_operand() {
		St_operandContext _localctx = new St_operandContext(Context, State);
		EnterRule(_localctx, 44, RULE_st_operand);
		try {
			State = 174;
			ErrorHandler.Sync(this);
			switch (TokenStream.LA(1)) {
			case GP_REGISTER:
			case SYSTEM_REGISTER:
			case INFO_REGISTER:
				EnterOuterAlt(_localctx, 1);
				{
				State = 172; op_register();
				}
				break;
			case SQ_L:
			case TILD:
			case LOCAL:
			case IDENTIFIER:
				EnterOuterAlt(_localctx, 2);
				{
				State = 173; jmp_operand();
				}
				break;
			default:
				throw new NoViableAltException(this);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class OperandsContext : ParserRuleContext {
		public St_operandContext[] st_operand() {
			return GetRuleContexts<St_operandContext>();
		}
		public St_operandContext st_operand(int i) {
			return GetRuleContext<St_operandContext>(i);
		}
		public ITerminalNode[] COMMA() { return GetTokens(PulsarAsmGrammarParser.COMMA); }
		public ITerminalNode COMMA(int i) {
			return GetToken(PulsarAsmGrammarParser.COMMA, i);
		}
		public Op_immediateContext op_immediate() {
			return GetRuleContext<Op_immediateContext>(0);
		}
		public OperandsContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_operands; } }
		public override void EnterRule(IParseTreeListener listener) {
			IPulsarAsmGrammarListener typedListener = listener as IPulsarAsmGrammarListener;
			if (typedListener != null) typedListener.EnterOperands(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IPulsarAsmGrammarListener typedListener = listener as IPulsarAsmGrammarListener;
			if (typedListener != null) typedListener.ExitOperands(this);
		}
	}

	[RuleVersion(0)]
	public OperandsContext operands() {
		OperandsContext _localctx = new OperandsContext(Context, State);
		EnterRule(_localctx, 46, RULE_operands);
		try {
			State = 199;
			ErrorHandler.Sync(this);
			switch ( Interpreter.AdaptivePredict(TokenStream,9,Context) ) {
			case 1:
				EnterOuterAlt(_localctx, 1);
				{
				State = 176; st_operand();
				State = 177; Match(COMMA);
				State = 178; st_operand();
				State = 179; Match(COMMA);
				State = 180; op_immediate();
				}
				break;
			case 2:
				EnterOuterAlt(_localctx, 2);
				{
				State = 182; st_operand();
				State = 183; Match(COMMA);
				State = 184; st_operand();
				State = 185; Match(COMMA);
				State = 186; st_operand();
				}
				break;
			case 3:
				EnterOuterAlt(_localctx, 3);
				{
				State = 188; st_operand();
				State = 189; Match(COMMA);
				State = 190; op_immediate();
				}
				break;
			case 4:
				EnterOuterAlt(_localctx, 4);
				{
				State = 192; st_operand();
				State = 193; Match(COMMA);
				State = 194; st_operand();
				}
				break;
			case 5:
				EnterOuterAlt(_localctx, 5);
				{
				State = 196; op_immediate();
				}
				break;
			case 6:
				EnterOuterAlt(_localctx, 6);
				{
				State = 197; st_operand();
				}
				break;
			case 7:
				EnterOuterAlt(_localctx, 7);
				{
				}
				break;
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class LabelContext : ParserRuleContext {
		public ITerminalNode IDENTIFIER() { return GetToken(PulsarAsmGrammarParser.IDENTIFIER, 0); }
		public ITerminalNode COLON() { return GetToken(PulsarAsmGrammarParser.COLON, 0); }
		public LabelContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_label; } }
		public override void EnterRule(IParseTreeListener listener) {
			IPulsarAsmGrammarListener typedListener = listener as IPulsarAsmGrammarListener;
			if (typedListener != null) typedListener.EnterLabel(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IPulsarAsmGrammarListener typedListener = listener as IPulsarAsmGrammarListener;
			if (typedListener != null) typedListener.ExitLabel(this);
		}
	}

	[RuleVersion(0)]
	public LabelContext label() {
		LabelContext _localctx = new LabelContext(Context, State);
		EnterRule(_localctx, 48, RULE_label);
		try {
			State = 204;
			ErrorHandler.Sync(this);
			switch (TokenStream.LA(1)) {
			case IDENTIFIER:
				EnterOuterAlt(_localctx, 1);
				{
				State = 201; Match(IDENTIFIER);
				State = 202; Match(COLON);
				}
				break;
			case MNEMONIC:
				EnterOuterAlt(_localctx, 2);
				{
				}
				break;
			default:
				throw new NoViableAltException(this);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class Instr_specifier_sequenceContext : ParserRuleContext {
		public Instruction_specifierContext instruction_specifier() {
			return GetRuleContext<Instruction_specifierContext>(0);
		}
		public Instr_specifier_sequenceContext instr_specifier_sequence() {
			return GetRuleContext<Instr_specifier_sequenceContext>(0);
		}
		public Instr_specifier_sequenceContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_instr_specifier_sequence; } }
		public override void EnterRule(IParseTreeListener listener) {
			IPulsarAsmGrammarListener typedListener = listener as IPulsarAsmGrammarListener;
			if (typedListener != null) typedListener.EnterInstr_specifier_sequence(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IPulsarAsmGrammarListener typedListener = listener as IPulsarAsmGrammarListener;
			if (typedListener != null) typedListener.ExitInstr_specifier_sequence(this);
		}
	}

	[RuleVersion(0)]
	public Instr_specifier_sequenceContext instr_specifier_sequence() {
		Instr_specifier_sequenceContext _localctx = new Instr_specifier_sequenceContext(Context, State);
		EnterRule(_localctx, 50, RULE_instr_specifier_sequence);
		try {
			State = 210;
			ErrorHandler.Sync(this);
			switch ( Interpreter.AdaptivePredict(TokenStream,11,Context) ) {
			case 1:
				EnterOuterAlt(_localctx, 1);
				{
				State = 206; instruction_specifier();
				State = 207; instr_specifier_sequence();
				}
				break;
			case 2:
				EnterOuterAlt(_localctx, 2);
				{
				}
				break;
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class Instr_bodyContext : ParserRuleContext {
		public LabelContext label() {
			return GetRuleContext<LabelContext>(0);
		}
		public ITerminalNode MNEMONIC() { return GetToken(PulsarAsmGrammarParser.MNEMONIC, 0); }
		public Instr_specifier_sequenceContext instr_specifier_sequence() {
			return GetRuleContext<Instr_specifier_sequenceContext>(0);
		}
		public OperandsContext operands() {
			return GetRuleContext<OperandsContext>(0);
		}
		public Instr_bodyContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_instr_body; } }
		public override void EnterRule(IParseTreeListener listener) {
			IPulsarAsmGrammarListener typedListener = listener as IPulsarAsmGrammarListener;
			if (typedListener != null) typedListener.EnterInstr_body(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IPulsarAsmGrammarListener typedListener = listener as IPulsarAsmGrammarListener;
			if (typedListener != null) typedListener.ExitInstr_body(this);
		}
	}

	[RuleVersion(0)]
	public Instr_bodyContext instr_body() {
		Instr_bodyContext _localctx = new Instr_bodyContext(Context, State);
		EnterRule(_localctx, 52, RULE_instr_body);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 212; label();
			State = 213; Match(MNEMONIC);
			State = 214; instr_specifier_sequence();
			State = 215; operands();
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class Jump_sequenceContext : ParserRuleContext {
		public Jmp_operandContext[] jmp_operand() {
			return GetRuleContexts<Jmp_operandContext>();
		}
		public Jmp_operandContext jmp_operand(int i) {
			return GetRuleContext<Jmp_operandContext>(i);
		}
		public ITerminalNode COMMA() { return GetToken(PulsarAsmGrammarParser.COMMA, 0); }
		public Jump_sequenceContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_jump_sequence; } }
		public override void EnterRule(IParseTreeListener listener) {
			IPulsarAsmGrammarListener typedListener = listener as IPulsarAsmGrammarListener;
			if (typedListener != null) typedListener.EnterJump_sequence(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IPulsarAsmGrammarListener typedListener = listener as IPulsarAsmGrammarListener;
			if (typedListener != null) typedListener.ExitJump_sequence(this);
		}
	}

	[RuleVersion(0)]
	public Jump_sequenceContext jump_sequence() {
		Jump_sequenceContext _localctx = new Jump_sequenceContext(Context, State);
		EnterRule(_localctx, 54, RULE_jump_sequence);
		try {
			State = 222;
			ErrorHandler.Sync(this);
			switch ( Interpreter.AdaptivePredict(TokenStream,12,Context) ) {
			case 1:
				EnterOuterAlt(_localctx, 1);
				{
				State = 217; jmp_operand();
				State = 218; Match(COMMA);
				State = 219; jmp_operand();
				}
				break;
			case 2:
				EnterOuterAlt(_localctx, 2);
				{
				State = 221; jmp_operand();
				}
				break;
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class Conditional_body_sharedContext : ParserRuleContext {
		public Instr_bodyContext instr_body() {
			return GetRuleContext<Instr_bodyContext>(0);
		}
		public ITerminalNode COMMA() { return GetToken(PulsarAsmGrammarParser.COMMA, 0); }
		public ITerminalNode CONDITION() { return GetToken(PulsarAsmGrammarParser.CONDITION, 0); }
		public Conditional_body_sharedContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_conditional_body_shared; } }
		public override void EnterRule(IParseTreeListener listener) {
			IPulsarAsmGrammarListener typedListener = listener as IPulsarAsmGrammarListener;
			if (typedListener != null) typedListener.EnterConditional_body_shared(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IPulsarAsmGrammarListener typedListener = listener as IPulsarAsmGrammarListener;
			if (typedListener != null) typedListener.ExitConditional_body_shared(this);
		}
	}

	[RuleVersion(0)]
	public Conditional_body_sharedContext conditional_body_shared() {
		Conditional_body_sharedContext _localctx = new Conditional_body_sharedContext(Context, State);
		EnterRule(_localctx, 56, RULE_conditional_body_shared);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 224; instr_body();
			State = 225; Match(COMMA);
			State = 226; Match(CONDITION);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class Conditional_instructionContext : ParserRuleContext {
		public Conditional_body_sharedContext conditional_body_shared() {
			return GetRuleContext<Conditional_body_sharedContext>(0);
		}
		public Jump_sequenceContext jump_sequence() {
			return GetRuleContext<Jump_sequenceContext>(0);
		}
		public Conditional_instructionContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_conditional_instruction; } }
		public override void EnterRule(IParseTreeListener listener) {
			IPulsarAsmGrammarListener typedListener = listener as IPulsarAsmGrammarListener;
			if (typedListener != null) typedListener.EnterConditional_instruction(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IPulsarAsmGrammarListener typedListener = listener as IPulsarAsmGrammarListener;
			if (typedListener != null) typedListener.ExitConditional_instruction(this);
		}
	}

	[RuleVersion(0)]
	public Conditional_instructionContext conditional_instruction() {
		Conditional_instructionContext _localctx = new Conditional_instructionContext(Context, State);
		EnterRule(_localctx, 58, RULE_conditional_instruction);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 228; conditional_body_shared();
			State = 229; jump_sequence();
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class Conditional_cp_instructionContext : ParserRuleContext {
		public Conditional_body_sharedContext conditional_body_shared() {
			return GetRuleContext<Conditional_body_sharedContext>(0);
		}
		public ITerminalNode SETBOOL() { return GetToken(PulsarAsmGrammarParser.SETBOOL, 0); }
		public St_operandContext st_operand() {
			return GetRuleContext<St_operandContext>(0);
		}
		public Conditional_cp_instructionContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_conditional_cp_instruction; } }
		public override void EnterRule(IParseTreeListener listener) {
			IPulsarAsmGrammarListener typedListener = listener as IPulsarAsmGrammarListener;
			if (typedListener != null) typedListener.EnterConditional_cp_instruction(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IPulsarAsmGrammarListener typedListener = listener as IPulsarAsmGrammarListener;
			if (typedListener != null) typedListener.ExitConditional_cp_instruction(this);
		}
	}

	[RuleVersion(0)]
	public Conditional_cp_instructionContext conditional_cp_instruction() {
		Conditional_cp_instructionContext _localctx = new Conditional_cp_instructionContext(Context, State);
		EnterRule(_localctx, 60, RULE_conditional_cp_instruction);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 231; conditional_body_shared();
			State = 232; Match(SETBOOL);
			State = 233; st_operand();
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class InstructionContext : ParserRuleContext {
		public Conditional_instructionContext conditional_instruction() {
			return GetRuleContext<Conditional_instructionContext>(0);
		}
		public Conditional_cp_instructionContext conditional_cp_instruction() {
			return GetRuleContext<Conditional_cp_instructionContext>(0);
		}
		public Instr_bodyContext instr_body() {
			return GetRuleContext<Instr_bodyContext>(0);
		}
		public InstructionContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_instruction; } }
		public override void EnterRule(IParseTreeListener listener) {
			IPulsarAsmGrammarListener typedListener = listener as IPulsarAsmGrammarListener;
			if (typedListener != null) typedListener.EnterInstruction(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IPulsarAsmGrammarListener typedListener = listener as IPulsarAsmGrammarListener;
			if (typedListener != null) typedListener.ExitInstruction(this);
		}
	}

	[RuleVersion(0)]
	public InstructionContext instruction() {
		InstructionContext _localctx = new InstructionContext(Context, State);
		EnterRule(_localctx, 62, RULE_instruction);
		try {
			State = 238;
			ErrorHandler.Sync(this);
			switch ( Interpreter.AdaptivePredict(TokenStream,13,Context) ) {
			case 1:
				EnterOuterAlt(_localctx, 1);
				{
				State = 235; conditional_instruction();
				}
				break;
			case 2:
				EnterOuterAlt(_localctx, 2);
				{
				State = 236; conditional_cp_instruction();
				}
				break;
			case 3:
				EnterOuterAlt(_localctx, 3);
				{
				State = 237; instr_body();
				}
				break;
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class Proc_elementContext : ParserRuleContext {
		public InstructionContext instruction() {
			return GetRuleContext<InstructionContext>(0);
		}
		public Data_definition_statementContext data_definition_statement() {
			return GetRuleContext<Data_definition_statementContext>(0);
		}
		public Proc_elementContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_proc_element; } }
		public override void EnterRule(IParseTreeListener listener) {
			IPulsarAsmGrammarListener typedListener = listener as IPulsarAsmGrammarListener;
			if (typedListener != null) typedListener.EnterProc_element(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IPulsarAsmGrammarListener typedListener = listener as IPulsarAsmGrammarListener;
			if (typedListener != null) typedListener.ExitProc_element(this);
		}
	}

	[RuleVersion(0)]
	public Proc_elementContext proc_element() {
		Proc_elementContext _localctx = new Proc_elementContext(Context, State);
		EnterRule(_localctx, 64, RULE_proc_element);
		try {
			State = 242;
			ErrorHandler.Sync(this);
			switch (TokenStream.LA(1)) {
			case MNEMONIC:
			case IDENTIFIER:
				EnterOuterAlt(_localctx, 1);
				{
				State = 240; instruction();
				}
				break;
			case DATA_TYPE_SPECIFIER:
				EnterOuterAlt(_localctx, 2);
				{
				State = 241; data_definition_statement();
				}
				break;
			default:
				throw new NoViableAltException(this);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class Proc_element_sequenceContext : ParserRuleContext {
		public Proc_elementContext proc_element() {
			return GetRuleContext<Proc_elementContext>(0);
		}
		public Proc_element_sequenceContext proc_element_sequence() {
			return GetRuleContext<Proc_element_sequenceContext>(0);
		}
		public Proc_element_sequenceContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_proc_element_sequence; } }
		public override void EnterRule(IParseTreeListener listener) {
			IPulsarAsmGrammarListener typedListener = listener as IPulsarAsmGrammarListener;
			if (typedListener != null) typedListener.EnterProc_element_sequence(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IPulsarAsmGrammarListener typedListener = listener as IPulsarAsmGrammarListener;
			if (typedListener != null) typedListener.ExitProc_element_sequence(this);
		}
	}

	[RuleVersion(0)]
	public Proc_element_sequenceContext proc_element_sequence() {
		Proc_element_sequenceContext _localctx = new Proc_element_sequenceContext(Context, State);
		EnterRule(_localctx, 66, RULE_proc_element_sequence);
		try {
			State = 248;
			ErrorHandler.Sync(this);
			switch ( Interpreter.AdaptivePredict(TokenStream,15,Context) ) {
			case 1:
				EnterOuterAlt(_localctx, 1);
				{
				State = 244; proc_element();
				State = 245; proc_element_sequence();
				}
				break;
			case 2:
				EnterOuterAlt(_localctx, 2);
				{
				State = 247; proc_element();
				}
				break;
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class ProcedureContext : ParserRuleContext {
		public Proc_headerContext proc_header() {
			return GetRuleContext<Proc_headerContext>(0);
		}
		public ITerminalNode PROC_START() { return GetToken(PulsarAsmGrammarParser.PROC_START, 0); }
		public Proc_element_sequenceContext proc_element_sequence() {
			return GetRuleContext<Proc_element_sequenceContext>(0);
		}
		public ITerminalNode PROC_END() { return GetToken(PulsarAsmGrammarParser.PROC_END, 0); }
		public ProcedureContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_procedure; } }
		public override void EnterRule(IParseTreeListener listener) {
			IPulsarAsmGrammarListener typedListener = listener as IPulsarAsmGrammarListener;
			if (typedListener != null) typedListener.EnterProcedure(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IPulsarAsmGrammarListener typedListener = listener as IPulsarAsmGrammarListener;
			if (typedListener != null) typedListener.ExitProcedure(this);
		}
	}

	[RuleVersion(0)]
	public ProcedureContext procedure() {
		ProcedureContext _localctx = new ProcedureContext(Context, State);
		EnterRule(_localctx, 68, RULE_procedure);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 250; proc_header();
			State = 251; Match(PROC_START);
			State = 252; proc_element_sequence();
			State = 253; Match(PROC_END);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class Asm_file_elementContext : ParserRuleContext {
		public DirectiveContext directive() {
			return GetRuleContext<DirectiveContext>(0);
		}
		public Data_definition_statementContext data_definition_statement() {
			return GetRuleContext<Data_definition_statementContext>(0);
		}
		public InstructionContext instruction() {
			return GetRuleContext<InstructionContext>(0);
		}
		public ProcedureContext procedure() {
			return GetRuleContext<ProcedureContext>(0);
		}
		public Asm_file_elementContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_asm_file_element; } }
		public override void EnterRule(IParseTreeListener listener) {
			IPulsarAsmGrammarListener typedListener = listener as IPulsarAsmGrammarListener;
			if (typedListener != null) typedListener.EnterAsm_file_element(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IPulsarAsmGrammarListener typedListener = listener as IPulsarAsmGrammarListener;
			if (typedListener != null) typedListener.ExitAsm_file_element(this);
		}
	}

	[RuleVersion(0)]
	public Asm_file_elementContext asm_file_element() {
		Asm_file_elementContext _localctx = new Asm_file_elementContext(Context, State);
		EnterRule(_localctx, 70, RULE_asm_file_element);
		try {
			State = 259;
			ErrorHandler.Sync(this);
			switch (TokenStream.LA(1)) {
			case BITNESS:
			case ADDRESSES:
			case ENDIANNESS_LITTLE:
			case ENDIANNESS_BIG:
				EnterOuterAlt(_localctx, 1);
				{
				State = 255; directive();
				}
				break;
			case DATA_TYPE_SPECIFIER:
				EnterOuterAlt(_localctx, 2);
				{
				State = 256; data_definition_statement();
				}
				break;
			case MNEMONIC:
			case IDENTIFIER:
				EnterOuterAlt(_localctx, 3);
				{
				State = 257; instruction();
				}
				break;
			case PROC:
				EnterOuterAlt(_localctx, 4);
				{
				State = 258; procedure();
				}
				break;
			default:
				throw new NoViableAltException(this);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class Asm_file_element_sequenceContext : ParserRuleContext {
		public Asm_file_elementContext asm_file_element() {
			return GetRuleContext<Asm_file_elementContext>(0);
		}
		public Asm_file_element_sequenceContext asm_file_element_sequence() {
			return GetRuleContext<Asm_file_element_sequenceContext>(0);
		}
		public Asm_file_element_sequenceContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_asm_file_element_sequence; } }
		public override void EnterRule(IParseTreeListener listener) {
			IPulsarAsmGrammarListener typedListener = listener as IPulsarAsmGrammarListener;
			if (typedListener != null) typedListener.EnterAsm_file_element_sequence(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IPulsarAsmGrammarListener typedListener = listener as IPulsarAsmGrammarListener;
			if (typedListener != null) typedListener.ExitAsm_file_element_sequence(this);
		}
	}

	[RuleVersion(0)]
	public Asm_file_element_sequenceContext asm_file_element_sequence() {
		Asm_file_element_sequenceContext _localctx = new Asm_file_element_sequenceContext(Context, State);
		EnterRule(_localctx, 72, RULE_asm_file_element_sequence);
		try {
			State = 265;
			ErrorHandler.Sync(this);
			switch ( Interpreter.AdaptivePredict(TokenStream,17,Context) ) {
			case 1:
				EnterOuterAlt(_localctx, 1);
				{
				State = 261; asm_file_element();
				State = 262; asm_file_element_sequence();
				}
				break;
			case 2:
				EnterOuterAlt(_localctx, 2);
				{
				State = 264; asm_file_element();
				}
				break;
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class Asm_fileContext : ParserRuleContext {
		public Asm_file_element_sequenceContext asm_file_element_sequence() {
			return GetRuleContext<Asm_file_element_sequenceContext>(0);
		}
		public Asm_fileContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_asm_file; } }
		public override void EnterRule(IParseTreeListener listener) {
			IPulsarAsmGrammarListener typedListener = listener as IPulsarAsmGrammarListener;
			if (typedListener != null) typedListener.EnterAsm_file(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IPulsarAsmGrammarListener typedListener = listener as IPulsarAsmGrammarListener;
			if (typedListener != null) typedListener.ExitAsm_file(this);
		}
	}

	[RuleVersion(0)]
	public Asm_fileContext asm_file() {
		Asm_fileContext _localctx = new Asm_fileContext(Context, State);
		EnterRule(_localctx, 74, RULE_asm_file);
		try {
			State = 269;
			ErrorHandler.Sync(this);
			switch (TokenStream.LA(1)) {
			case MNEMONIC:
			case BITNESS:
			case ADDRESSES:
			case ENDIANNESS_LITTLE:
			case ENDIANNESS_BIG:
			case DATA_TYPE_SPECIFIER:
			case PROC:
			case IDENTIFIER:
				EnterOuterAlt(_localctx, 1);
				{
				State = 267; asm_file_element_sequence();
				}
				break;
			case Eof:
				EnterOuterAlt(_localctx, 2);
				{
				}
				break;
			default:
				throw new NoViableAltException(this);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	private static char[] _serializedATN = {
		'\x3', '\x608B', '\xA72A', '\x8133', '\xB9ED', '\x417C', '\x3BE7', '\x7786', 
		'\x5964', '\x3', '$', '\x112', '\x4', '\x2', '\t', '\x2', '\x4', '\x3', 
		'\t', '\x3', '\x4', '\x4', '\t', '\x4', '\x4', '\x5', '\t', '\x5', '\x4', 
		'\x6', '\t', '\x6', '\x4', '\a', '\t', '\a', '\x4', '\b', '\t', '\b', 
		'\x4', '\t', '\t', '\t', '\x4', '\n', '\t', '\n', '\x4', '\v', '\t', '\v', 
		'\x4', '\f', '\t', '\f', '\x4', '\r', '\t', '\r', '\x4', '\xE', '\t', 
		'\xE', '\x4', '\xF', '\t', '\xF', '\x4', '\x10', '\t', '\x10', '\x4', 
		'\x11', '\t', '\x11', '\x4', '\x12', '\t', '\x12', '\x4', '\x13', '\t', 
		'\x13', '\x4', '\x14', '\t', '\x14', '\x4', '\x15', '\t', '\x15', '\x4', 
		'\x16', '\t', '\x16', '\x4', '\x17', '\t', '\x17', '\x4', '\x18', '\t', 
		'\x18', '\x4', '\x19', '\t', '\x19', '\x4', '\x1A', '\t', '\x1A', '\x4', 
		'\x1B', '\t', '\x1B', '\x4', '\x1C', '\t', '\x1C', '\x4', '\x1D', '\t', 
		'\x1D', '\x4', '\x1E', '\t', '\x1E', '\x4', '\x1F', '\t', '\x1F', '\x4', 
		' ', '\t', ' ', '\x4', '!', '\t', '!', '\x4', '\"', '\t', '\"', '\x4', 
		'#', '\t', '#', '\x4', '$', '\t', '$', '\x4', '%', '\t', '%', '\x4', '&', 
		'\t', '&', '\x4', '\'', '\t', '\'', '\x3', '\x2', '\x3', '\x2', '\x3', 
		'\x2', '\x3', '\x3', '\x3', '\x3', '\x3', '\x3', '\x3', '\x4', '\x3', 
		'\x4', '\x3', '\x4', '\x3', '\x4', '\x5', '\x4', 'Y', '\n', '\x4', '\x3', 
		'\x5', '\x3', '\x5', '\x3', '\x5', '\x3', '\x6', '\x3', '\x6', '\x3', 
		'\a', '\x3', '\a', '\x3', '\b', '\x3', '\b', '\x5', '\b', '\x64', '\n', 
		'\b', '\x3', '\t', '\x3', '\t', '\x5', '\t', 'h', '\n', '\t', '\x3', '\n', 
		'\x3', '\n', '\x3', '\n', '\x3', '\n', '\x3', '\n', '\x3', '\n', '\x3', 
		'\n', '\x5', '\n', 'q', '\n', '\n', '\x3', '\v', '\x3', '\v', '\x3', '\v', 
		'\x3', '\v', '\x5', '\v', 'w', '\n', '\v', '\x3', '\f', '\x3', '\f', '\x5', 
		'\f', '{', '\n', '\f', '\x3', '\r', '\x3', '\r', '\x3', '\r', '\x3', '\r', 
		'\x3', '\xE', '\x3', '\xE', '\x3', '\xE', '\x5', '\xE', '\x84', '\n', 
		'\xE', '\x3', '\xF', '\x3', '\xF', '\x3', '\x10', '\x3', '\x10', '\x3', 
		'\x10', '\x3', '\x10', '\x3', '\x11', '\x3', '\x11', '\x3', '\x11', '\x3', 
		'\x11', '\x3', '\x12', '\x3', '\x12', '\x3', '\x12', '\x3', '\x12', '\x3', 
		'\x12', '\x3', '\x13', '\x3', '\x13', '\x3', '\x13', '\x3', '\x13', '\x3', 
		'\x13', '\x3', '\x13', '\x3', '\x14', '\x3', '\x14', '\x3', '\x14', '\x3', 
		'\x14', '\x3', '\x14', '\x3', '\x14', '\x3', '\x15', '\x3', '\x15', '\x3', 
		'\x15', '\x3', '\x16', '\x3', '\x16', '\x3', '\x17', '\x3', '\x17', '\x3', 
		'\x17', '\x3', '\x17', '\x3', '\x17', '\x3', '\x17', '\x3', '\x17', '\x5', 
		'\x17', '\xAD', '\n', '\x17', '\x3', '\x18', '\x3', '\x18', '\x5', '\x18', 
		'\xB1', '\n', '\x18', '\x3', '\x19', '\x3', '\x19', '\x3', '\x19', '\x3', 
		'\x19', '\x3', '\x19', '\x3', '\x19', '\x3', '\x19', '\x3', '\x19', '\x3', 
		'\x19', '\x3', '\x19', '\x3', '\x19', '\x3', '\x19', '\x3', '\x19', '\x3', 
		'\x19', '\x3', '\x19', '\x3', '\x19', '\x3', '\x19', '\x3', '\x19', '\x3', 
		'\x19', '\x3', '\x19', '\x3', '\x19', '\x3', '\x19', '\x3', '\x19', '\x5', 
		'\x19', '\xCA', '\n', '\x19', '\x3', '\x1A', '\x3', '\x1A', '\x3', '\x1A', 
		'\x5', '\x1A', '\xCF', '\n', '\x1A', '\x3', '\x1B', '\x3', '\x1B', '\x3', 
		'\x1B', '\x3', '\x1B', '\x5', '\x1B', '\xD5', '\n', '\x1B', '\x3', '\x1C', 
		'\x3', '\x1C', '\x3', '\x1C', '\x3', '\x1C', '\x3', '\x1C', '\x3', '\x1D', 
		'\x3', '\x1D', '\x3', '\x1D', '\x3', '\x1D', '\x3', '\x1D', '\x5', '\x1D', 
		'\xE1', '\n', '\x1D', '\x3', '\x1E', '\x3', '\x1E', '\x3', '\x1E', '\x3', 
		'\x1E', '\x3', '\x1F', '\x3', '\x1F', '\x3', '\x1F', '\x3', ' ', '\x3', 
		' ', '\x3', ' ', '\x3', ' ', '\x3', '!', '\x3', '!', '\x3', '!', '\x5', 
		'!', '\xF1', '\n', '!', '\x3', '\"', '\x3', '\"', '\x5', '\"', '\xF5', 
		'\n', '\"', '\x3', '#', '\x3', '#', '\x3', '#', '\x3', '#', '\x5', '#', 
		'\xFB', '\n', '#', '\x3', '$', '\x3', '$', '\x3', '$', '\x3', '$', '\x3', 
		'$', '\x3', '%', '\x3', '%', '\x3', '%', '\x3', '%', '\x5', '%', '\x106', 
		'\n', '%', '\x3', '&', '\x3', '&', '\x3', '&', '\x3', '&', '\x5', '&', 
		'\x10C', '\n', '&', '\x3', '\'', '\x3', '\'', '\x5', '\'', '\x110', '\n', 
		'\'', '\x3', '\'', '\x2', '\x2', '(', '\x2', '\x4', '\x6', '\b', '\n', 
		'\f', '\xE', '\x10', '\x12', '\x14', '\x16', '\x18', '\x1A', '\x1C', '\x1E', 
		' ', '\"', '$', '&', '(', '*', ',', '.', '\x30', '\x32', '\x34', '\x36', 
		'\x38', ':', '<', '>', '@', '\x42', '\x44', '\x46', 'H', 'J', 'L', '\x2', 
		'\x5', '\x3', '\x2', '\x12', '\x14', '\x4', '\x2', '\n', '\n', '\f', '\r', 
		'\x3', '\x2', '\x15', '\x17', '\x2', '\x10D', '\x2', 'N', '\x3', '\x2', 
		'\x2', '\x2', '\x4', 'Q', '\x3', '\x2', '\x2', '\x2', '\x6', 'X', '\x3', 
		'\x2', '\x2', '\x2', '\b', 'Z', '\x3', '\x2', '\x2', '\x2', '\n', ']', 
		'\x3', '\x2', '\x2', '\x2', '\f', '_', '\x3', '\x2', '\x2', '\x2', '\xE', 
		'\x63', '\x3', '\x2', '\x2', '\x2', '\x10', 'g', '\x3', '\x2', '\x2', 
		'\x2', '\x12', 'p', '\x3', '\x2', '\x2', '\x2', '\x14', 'v', '\x3', '\x2', 
		'\x2', '\x2', '\x16', 'z', '\x3', '\x2', '\x2', '\x2', '\x18', '|', '\x3', 
		'\x2', '\x2', '\x2', '\x1A', '\x83', '\x3', '\x2', '\x2', '\x2', '\x1C', 
		'\x85', '\x3', '\x2', '\x2', '\x2', '\x1E', '\x87', '\x3', '\x2', '\x2', 
		'\x2', ' ', '\x8B', '\x3', '\x2', '\x2', '\x2', '\"', '\x8F', '\x3', '\x2', 
		'\x2', '\x2', '$', '\x94', '\x3', '\x2', '\x2', '\x2', '&', '\x9A', '\x3', 
		'\x2', '\x2', '\x2', '(', '\xA0', '\x3', '\x2', '\x2', '\x2', '*', '\xA3', 
		'\x3', '\x2', '\x2', '\x2', ',', '\xAC', '\x3', '\x2', '\x2', '\x2', '.', 
		'\xB0', '\x3', '\x2', '\x2', '\x2', '\x30', '\xC9', '\x3', '\x2', '\x2', 
		'\x2', '\x32', '\xCE', '\x3', '\x2', '\x2', '\x2', '\x34', '\xD4', '\x3', 
		'\x2', '\x2', '\x2', '\x36', '\xD6', '\x3', '\x2', '\x2', '\x2', '\x38', 
		'\xE0', '\x3', '\x2', '\x2', '\x2', ':', '\xE2', '\x3', '\x2', '\x2', 
		'\x2', '<', '\xE6', '\x3', '\x2', '\x2', '\x2', '>', '\xE9', '\x3', '\x2', 
		'\x2', '\x2', '@', '\xF0', '\x3', '\x2', '\x2', '\x2', '\x42', '\xF4', 
		'\x3', '\x2', '\x2', '\x2', '\x44', '\xFA', '\x3', '\x2', '\x2', '\x2', 
		'\x46', '\xFC', '\x3', '\x2', '\x2', '\x2', 'H', '\x105', '\x3', '\x2', 
		'\x2', '\x2', 'J', '\x10B', '\x3', '\x2', '\x2', '\x2', 'L', '\x10F', 
		'\x3', '\x2', '\x2', '\x2', 'N', 'O', '\a', '\xE', '\x2', '\x2', 'O', 
		'P', '\a', '\n', '\x2', '\x2', 'P', '\x3', '\x3', '\x2', '\x2', '\x2', 
		'Q', 'R', '\a', '\xF', '\x2', '\x2', 'R', 'S', '\a', '\n', '\x2', '\x2', 
		'S', '\x5', '\x3', '\x2', '\x2', '\x2', 'T', 'Y', '\x5', '\x2', '\x2', 
		'\x2', 'U', 'Y', '\x5', '\x4', '\x3', '\x2', 'V', 'Y', '\a', '\x10', '\x2', 
		'\x2', 'W', 'Y', '\a', '\x11', '\x2', '\x2', 'X', 'T', '\x3', '\x2', '\x2', 
		'\x2', 'X', 'U', '\x3', '\x2', '\x2', '\x2', 'X', 'V', '\x3', '\x2', '\x2', 
		'\x2', 'X', 'W', '\x3', '\x2', '\x2', '\x2', 'Y', '\a', '\x3', '\x2', 
		'\x2', '\x2', 'Z', '[', '\a', '\x19', '\x2', '\x2', '[', '\\', '\a', '$', 
		'\x2', '\x2', '\\', '\t', '\x3', '\x2', '\x2', '\x2', ']', '^', '\t', 
		'\x2', '\x2', '\x2', '^', '\v', '\x3', '\x2', '\x2', '\x2', '_', '`', 
		'\t', '\x3', '\x2', '\x2', '`', '\r', '\x3', '\x2', '\x2', '\x2', '\x61', 
		'\x64', '\x5', '\f', '\a', '\x2', '\x62', '\x64', '\a', '\v', '\x2', '\x2', 
		'\x63', '\x61', '\x3', '\x2', '\x2', '\x2', '\x63', '\x62', '\x3', '\x2', 
		'\x2', '\x2', '\x64', '\xF', '\x3', '\x2', '\x2', '\x2', '\x65', 'h', 
		'\x5', '\xE', '\b', '\x2', '\x66', 'h', '\a', '#', '\x2', '\x2', 'g', 
		'\x65', '\x3', '\x2', '\x2', '\x2', 'g', '\x66', '\x3', '\x2', '\x2', 
		'\x2', 'h', '\x11', '\x3', '\x2', '\x2', '\x2', 'i', 'j', '\x5', '\x10', 
		'\t', '\x2', 'j', 'k', '\a', '\t', '\x2', '\x2', 'k', 'l', '\x5', '\x12', 
		'\n', '\x2', 'l', 'q', '\x3', '\x2', '\x2', '\x2', 'm', 'n', '\x5', '\x10', 
		'\t', '\x2', 'n', 'o', '\a', '\t', '\x2', '\x2', 'o', 'q', '\x3', '\x2', 
		'\x2', '\x2', 'p', 'i', '\x3', '\x2', '\x2', '\x2', 'p', 'm', '\x3', '\x2', 
		'\x2', '\x2', 'q', '\x13', '\x3', '\x2', '\x2', '\x2', 'r', 's', '\x5', 
		'\x12', '\n', '\x2', 's', 't', '\x5', '\x10', '\t', '\x2', 't', 'w', '\x3', 
		'\x2', '\x2', '\x2', 'u', 'w', '\x5', '\x10', '\t', '\x2', 'v', 'r', '\x3', 
		'\x2', '\x2', '\x2', 'v', 'u', '\x3', '\x2', '\x2', '\x2', 'w', '\x15', 
		'\x3', '\x2', '\x2', '\x2', 'x', '{', '\a', '$', '\x2', '\x2', 'y', '{', 
		'\x3', '\x2', '\x2', '\x2', 'z', 'x', '\x3', '\x2', '\x2', '\x2', 'z', 
		'y', '\x3', '\x2', '\x2', '\x2', '{', '\x17', '\x3', '\x2', '\x2', '\x2', 
		'|', '}', '\a', '\x12', '\x2', '\x2', '}', '~', '\x5', '\x16', '\f', '\x2', 
		'~', '\x7F', '\x5', '\x14', '\v', '\x2', '\x7F', '\x19', '\x3', '\x2', 
		'\x2', '\x2', '\x80', '\x81', '\a', ' ', '\x2', '\x2', '\x81', '\x84', 
		'\a', '$', '\x2', '\x2', '\x82', '\x84', '\x5', '\xE', '\b', '\x2', '\x83', 
		'\x80', '\x3', '\x2', '\x2', '\x2', '\x83', '\x82', '\x3', '\x2', '\x2', 
		'\x2', '\x84', '\x1B', '\x3', '\x2', '\x2', '\x2', '\x85', '\x86', '\t', 
		'\x4', '\x2', '\x2', '\x86', '\x1D', '\x3', '\x2', '\x2', '\x2', '\x87', 
		'\x88', '\a', '\x1C', '\x2', '\x2', '\x88', '\x89', '\x5', '\xE', '\b', 
		'\x2', '\x89', '\x8A', '\a', '\x1D', '\x2', '\x2', '\x8A', '\x1F', '\x3', 
		'\x2', '\x2', '\x2', '\x8B', '\x8C', '\a', '\x1C', '\x2', '\x2', '\x8C', 
		'\x8D', '\a', '\x15', '\x2', '\x2', '\x8D', '\x8E', '\a', '\x1D', '\x2', 
		'\x2', '\x8E', '!', '\x3', '\x2', '\x2', '\x2', '\x8F', '\x90', '\a', 
		'!', '\x2', '\x2', '\x90', '\x91', '\a', '\x1C', '\x2', '\x2', '\x91', 
		'\x92', '\x5', '\xE', '\b', '\x2', '\x92', '\x93', '\a', '\x1D', '\x2', 
		'\x2', '\x93', '#', '\x3', '\x2', '\x2', '\x2', '\x94', '\x95', '\a', 
		'\x1C', '\x2', '\x2', '\x95', '\x96', '\a', '\x15', '\x2', '\x2', '\x96', 
		'\x97', '\a', '\b', '\x2', '\x2', '\x97', '\x98', '\x5', '\f', '\a', '\x2', 
		'\x98', '\x99', '\a', '\x1D', '\x2', '\x2', '\x99', '%', '\x3', '\x2', 
		'\x2', '\x2', '\x9A', '\x9B', '\a', '\x1C', '\x2', '\x2', '\x9B', '\x9C', 
		'\a', '\x15', '\x2', '\x2', '\x9C', '\x9D', '\a', '\a', '\x2', '\x2', 
		'\x9D', '\x9E', '\a', '\x15', '\x2', '\x2', '\x9E', '\x9F', '\a', '\x1D', 
		'\x2', '\x2', '\x9F', '\'', '\x3', '\x2', '\x2', '\x2', '\xA0', '\xA1', 
		'\a', '\x1E', '\x2', '\x2', '\xA1', '\xA2', '\x5', '\xE', '\b', '\x2', 
		'\xA2', ')', '\x3', '\x2', '\x2', '\x2', '\xA3', '\xA4', '\a', '$', '\x2', 
		'\x2', '\xA4', '+', '\x3', '\x2', '\x2', '\x2', '\xA5', '\xAD', '\x5', 
		'\x1E', '\x10', '\x2', '\xA6', '\xAD', '\x5', ' ', '\x11', '\x2', '\xA7', 
		'\xAD', '\x5', '\"', '\x12', '\x2', '\xA8', '\xAD', '\x5', '$', '\x13', 
		'\x2', '\xA9', '\xAD', '\x5', '&', '\x14', '\x2', '\xAA', '\xAD', '\x5', 
		'(', '\x15', '\x2', '\xAB', '\xAD', '\x5', '*', '\x16', '\x2', '\xAC', 
		'\xA5', '\x3', '\x2', '\x2', '\x2', '\xAC', '\xA6', '\x3', '\x2', '\x2', 
		'\x2', '\xAC', '\xA7', '\x3', '\x2', '\x2', '\x2', '\xAC', '\xA8', '\x3', 
		'\x2', '\x2', '\x2', '\xAC', '\xA9', '\x3', '\x2', '\x2', '\x2', '\xAC', 
		'\xAA', '\x3', '\x2', '\x2', '\x2', '\xAC', '\xAB', '\x3', '\x2', '\x2', 
		'\x2', '\xAD', '-', '\x3', '\x2', '\x2', '\x2', '\xAE', '\xB1', '\x5', 
		'\x1C', '\xF', '\x2', '\xAF', '\xB1', '\x5', ',', '\x17', '\x2', '\xB0', 
		'\xAE', '\x3', '\x2', '\x2', '\x2', '\xB0', '\xAF', '\x3', '\x2', '\x2', 
		'\x2', '\xB1', '/', '\x3', '\x2', '\x2', '\x2', '\xB2', '\xB3', '\x5', 
		'.', '\x18', '\x2', '\xB3', '\xB4', '\a', '\t', '\x2', '\x2', '\xB4', 
		'\xB5', '\x5', '.', '\x18', '\x2', '\xB5', '\xB6', '\a', '\t', '\x2', 
		'\x2', '\xB6', '\xB7', '\x5', '\x1A', '\xE', '\x2', '\xB7', '\xCA', '\x3', 
		'\x2', '\x2', '\x2', '\xB8', '\xB9', '\x5', '.', '\x18', '\x2', '\xB9', 
		'\xBA', '\a', '\t', '\x2', '\x2', '\xBA', '\xBB', '\x5', '.', '\x18', 
		'\x2', '\xBB', '\xBC', '\a', '\t', '\x2', '\x2', '\xBC', '\xBD', '\x5', 
		'.', '\x18', '\x2', '\xBD', '\xCA', '\x3', '\x2', '\x2', '\x2', '\xBE', 
		'\xBF', '\x5', '.', '\x18', '\x2', '\xBF', '\xC0', '\a', '\t', '\x2', 
		'\x2', '\xC0', '\xC1', '\x5', '\x1A', '\xE', '\x2', '\xC1', '\xCA', '\x3', 
		'\x2', '\x2', '\x2', '\xC2', '\xC3', '\x5', '.', '\x18', '\x2', '\xC3', 
		'\xC4', '\a', '\t', '\x2', '\x2', '\xC4', '\xC5', '\x5', '.', '\x18', 
		'\x2', '\xC5', '\xCA', '\x3', '\x2', '\x2', '\x2', '\xC6', '\xCA', '\x5', 
		'\x1A', '\xE', '\x2', '\xC7', '\xCA', '\x5', '.', '\x18', '\x2', '\xC8', 
		'\xCA', '\x3', '\x2', '\x2', '\x2', '\xC9', '\xB2', '\x3', '\x2', '\x2', 
		'\x2', '\xC9', '\xB8', '\x3', '\x2', '\x2', '\x2', '\xC9', '\xBE', '\x3', 
		'\x2', '\x2', '\x2', '\xC9', '\xC2', '\x3', '\x2', '\x2', '\x2', '\xC9', 
		'\xC6', '\x3', '\x2', '\x2', '\x2', '\xC9', '\xC7', '\x3', '\x2', '\x2', 
		'\x2', '\xC9', '\xC8', '\x3', '\x2', '\x2', '\x2', '\xCA', '\x31', '\x3', 
		'\x2', '\x2', '\x2', '\xCB', '\xCC', '\a', '$', '\x2', '\x2', '\xCC', 
		'\xCF', '\a', '\x1F', '\x2', '\x2', '\xCD', '\xCF', '\x3', '\x2', '\x2', 
		'\x2', '\xCE', '\xCB', '\x3', '\x2', '\x2', '\x2', '\xCE', '\xCD', '\x3', 
		'\x2', '\x2', '\x2', '\xCF', '\x33', '\x3', '\x2', '\x2', '\x2', '\xD0', 
		'\xD1', '\x5', '\n', '\x6', '\x2', '\xD1', '\xD2', '\x5', '\x34', '\x1B', 
		'\x2', '\xD2', '\xD5', '\x3', '\x2', '\x2', '\x2', '\xD3', '\xD5', '\x3', 
		'\x2', '\x2', '\x2', '\xD4', '\xD0', '\x3', '\x2', '\x2', '\x2', '\xD4', 
		'\xD3', '\x3', '\x2', '\x2', '\x2', '\xD5', '\x35', '\x3', '\x2', '\x2', 
		'\x2', '\xD6', '\xD7', '\x5', '\x32', '\x1A', '\x2', '\xD7', '\xD8', '\a', 
		'\x6', '\x2', '\x2', '\xD8', '\xD9', '\x5', '\x34', '\x1B', '\x2', '\xD9', 
		'\xDA', '\x5', '\x30', '\x19', '\x2', '\xDA', '\x37', '\x3', '\x2', '\x2', 
		'\x2', '\xDB', '\xDC', '\x5', ',', '\x17', '\x2', '\xDC', '\xDD', '\a', 
		'\t', '\x2', '\x2', '\xDD', '\xDE', '\x5', ',', '\x17', '\x2', '\xDE', 
		'\xE1', '\x3', '\x2', '\x2', '\x2', '\xDF', '\xE1', '\x5', ',', '\x17', 
		'\x2', '\xE0', '\xDB', '\x3', '\x2', '\x2', '\x2', '\xE0', '\xDF', '\x3', 
		'\x2', '\x2', '\x2', '\xE1', '\x39', '\x3', '\x2', '\x2', '\x2', '\xE2', 
		'\xE3', '\x5', '\x36', '\x1C', '\x2', '\xE3', '\xE4', '\a', '\t', '\x2', 
		'\x2', '\xE4', '\xE5', '\a', '\x18', '\x2', '\x2', '\xE5', ';', '\x3', 
		'\x2', '\x2', '\x2', '\xE6', '\xE7', '\x5', ':', '\x1E', '\x2', '\xE7', 
		'\xE8', '\x5', '\x38', '\x1D', '\x2', '\xE8', '=', '\x3', '\x2', '\x2', 
		'\x2', '\xE9', '\xEA', '\x5', ':', '\x1E', '\x2', '\xEA', '\xEB', '\a', 
		'\"', '\x2', '\x2', '\xEB', '\xEC', '\x5', '.', '\x18', '\x2', '\xEC', 
		'?', '\x3', '\x2', '\x2', '\x2', '\xED', '\xF1', '\x5', '<', '\x1F', '\x2', 
		'\xEE', '\xF1', '\x5', '>', ' ', '\x2', '\xEF', '\xF1', '\x5', '\x36', 
		'\x1C', '\x2', '\xF0', '\xED', '\x3', '\x2', '\x2', '\x2', '\xF0', '\xEE', 
		'\x3', '\x2', '\x2', '\x2', '\xF0', '\xEF', '\x3', '\x2', '\x2', '\x2', 
		'\xF1', '\x41', '\x3', '\x2', '\x2', '\x2', '\xF2', '\xF5', '\x5', '@', 
		'!', '\x2', '\xF3', '\xF5', '\x5', '\x18', '\r', '\x2', '\xF4', '\xF2', 
		'\x3', '\x2', '\x2', '\x2', '\xF4', '\xF3', '\x3', '\x2', '\x2', '\x2', 
		'\xF5', '\x43', '\x3', '\x2', '\x2', '\x2', '\xF6', '\xF7', '\x5', '\x42', 
		'\"', '\x2', '\xF7', '\xF8', '\x5', '\x44', '#', '\x2', '\xF8', '\xFB', 
		'\x3', '\x2', '\x2', '\x2', '\xF9', '\xFB', '\x5', '\x42', '\"', '\x2', 
		'\xFA', '\xF6', '\x3', '\x2', '\x2', '\x2', '\xFA', '\xF9', '\x3', '\x2', 
		'\x2', '\x2', '\xFB', '\x45', '\x3', '\x2', '\x2', '\x2', '\xFC', '\xFD', 
		'\x5', '\b', '\x5', '\x2', '\xFD', '\xFE', '\a', '\x1A', '\x2', '\x2', 
		'\xFE', '\xFF', '\x5', '\x44', '#', '\x2', '\xFF', '\x100', '\a', '\x1B', 
		'\x2', '\x2', '\x100', 'G', '\x3', '\x2', '\x2', '\x2', '\x101', '\x106', 
		'\x5', '\x6', '\x4', '\x2', '\x102', '\x106', '\x5', '\x18', '\r', '\x2', 
		'\x103', '\x106', '\x5', '@', '!', '\x2', '\x104', '\x106', '\x5', '\x46', 
		'$', '\x2', '\x105', '\x101', '\x3', '\x2', '\x2', '\x2', '\x105', '\x102', 
		'\x3', '\x2', '\x2', '\x2', '\x105', '\x103', '\x3', '\x2', '\x2', '\x2', 
		'\x105', '\x104', '\x3', '\x2', '\x2', '\x2', '\x106', 'I', '\x3', '\x2', 
		'\x2', '\x2', '\x107', '\x108', '\x5', 'H', '%', '\x2', '\x108', '\x109', 
		'\x5', 'J', '&', '\x2', '\x109', '\x10C', '\x3', '\x2', '\x2', '\x2', 
		'\x10A', '\x10C', '\x5', 'H', '%', '\x2', '\x10B', '\x107', '\x3', '\x2', 
		'\x2', '\x2', '\x10B', '\x10A', '\x3', '\x2', '\x2', '\x2', '\x10C', 'K', 
		'\x3', '\x2', '\x2', '\x2', '\x10D', '\x110', '\x5', 'J', '&', '\x2', 
		'\x10E', '\x110', '\x3', '\x2', '\x2', '\x2', '\x10F', '\x10D', '\x3', 
		'\x2', '\x2', '\x2', '\x10F', '\x10E', '\x3', '\x2', '\x2', '\x2', '\x110', 
		'M', '\x3', '\x2', '\x2', '\x2', '\x15', 'X', '\x63', 'g', 'p', 'v', 'z', 
		'\x83', '\xAC', '\xB0', '\xC9', '\xCE', '\xD4', '\xE0', '\xF0', '\xF4', 
		'\xFA', '\x105', '\x10B', '\x10F',
	};

	public static readonly ATN _ATN =
		new ATNDeserializer().Deserialize(_serializedATN);


}
